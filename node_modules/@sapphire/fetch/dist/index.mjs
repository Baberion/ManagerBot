import { fetch as fetch$1 } from 'cross-fetch';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

// eslint-disable-next-line spaced-comment
/// <reference lib="dom" />
var _QueryError_json;
/**
 * The QueryError class which is thrown by the `fetch` method
 */
class QueryError extends Error {
    constructor(url, code, response, body) {
        super(`Failed to request '${url}' with code ${code}.`);
        /** The requested url. */
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The HTTP status code. */
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The returned response body as a string */
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The original {@link Response} object */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _QueryError_json.set(this, void 0);
        this.url = url;
        this.code = code;
        this.body = body;
        this.response = response;
        __classPrivateFieldSet(this, _QueryError_json, null, "f");
    }
    toJSON() {
        return __classPrivateFieldGet(this, _QueryError_json, "f") ?? (__classPrivateFieldSet(this, _QueryError_json, JSON.parse(this.body), "f"));
    }
}
_QueryError_json = new WeakMap();

/**
 * The supported return types for the `fetch` method
 */
var FetchResultTypes;
(function (FetchResultTypes) {
    /**
     * Returns only the body, as JSON. Similar to [`Body.json()`](https://developer.mozilla.org/en-US/docs/Web/API/Body/json).
     *
     * You should provide your own type cast (either through the generic return type, or with `as <type>`) to the response to define
     * the JSON structure, otherwise the result will be `unknown`.
     */
    FetchResultTypes["JSON"] = "json";
    /**
     * Returns only the body, as a [Buffer](https://nodejs.org/api/buffer.html).
     * @remark Does not work in a Browser environment. For browsers use {@link FetchResultTypes.Blob} instead.
     * If you use this type in a Browsers environment a {@link ReferenceError `ReferenceError: Buffer is not defined`} will be thrown!
     */
    FetchResultTypes["Buffer"] = "buffer";
    /**
     * Returns only the body, as a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).
     * @remark For NodeJS environment other `FetchResultTypes` are recommended, but you can use a Blob if you want to.
     */
    FetchResultTypes["Blob"] = "blob";
    /**
     * Returns only the body, as plain text. Similar to [`Body.text()`](https://developer.mozilla.org/en-US/docs/Web/API/Body/text).
     */
    FetchResultTypes["Text"] = "text";
    /**
     * Returns the entire response and doesn't parse the `body` in any way.
     */
    FetchResultTypes["Result"] = "result";
})(FetchResultTypes || (FetchResultTypes = {}));
/**
 * The list of [HTTP Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
 */
var FetchMethods;
(function (FetchMethods) {
    /**
     * The `GET` method requests a representation of the specified resource. Requests using `GET` should only retrieve data.
     * @see [MDN / Web / HTTP / Methods / GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET)
     */
    FetchMethods["Get"] = "GET";
    /**
     * The `HEAD` method asks for a response identical to that of a {@link FetchMethods.Get `GET`} request, but without the response body.
     * @see [MDN / Web / HTTP / Methods / HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD)
     */
    FetchMethods["Head"] = "HEAD";
    /**
     * The `POST` method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.
     * @see [MDN / Web / HTTP / Methods / POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
     */
    FetchMethods["Post"] = "POST";
    /**
     * The `PUT` method replaces all current representations of the target resource with the request payload.
     * @see [MDN / Web / HTTP / Methods / PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT)
     */
    FetchMethods["Put"] = "PUT";
    /**
     * The `DELETE` method deletes the specified resource.
     * @see [MDN / Web / HTTP / Methods / DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE)
     */
    FetchMethods["Delete"] = "DELETE";
    /**
     *  The `CONNECT` method establishes a tunnel to the server identified by the target resource
     * @see [MDN / Web / HTTP / Methods / CONNECT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT)
     */
    FetchMethods["Connect"] = "CONNECT";
    /**
     * The `OPTIONS` method is used to describe the communication options for the target resource.
     * @see [MDN / Web / HTTP / Methods / OPTIONS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS)
     */
    FetchMethods["Options"] = "OPTIONS";
    /**
     * The `TRACE` method performs a message loop-back test along the path to the target resource.
     * @see [MDN / Web / HTTP / Methods / TRACE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE)
     */
    FetchMethods["Trace"] = "TRACE";
    /**
     * The `PATCH` method is used to apply partial modifications to a resource.
     * @see [MDN / Web / HTTP / Methods / PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH)
     */
    FetchMethods["Patch"] = "PATCH";
})(FetchMethods || (FetchMethods = {}));

// eslint-disable-next-line spaced-comment
async function fetch(url, options, type) {
    if (typeof options === 'undefined') {
        options = {};
        type = "json" /* JSON */;
    }
    else if (typeof options === 'string') {
        type = options;
        options = {};
    }
    else if (typeof type === 'undefined') {
        type = "json" /* JSON */;
    }
    // Transform the URL to a String, in case an URL object was passed
    const stringUrl = String(url);
    const result = await fetch$1(stringUrl, options);
    if (!result.ok)
        throw new QueryError(stringUrl, result.status, result, await result.clone().text());
    switch (type) {
        case "result" /* Result */:
            return result;
        case "buffer" /* Buffer */:
            return Buffer.from(await (await result.blob()).arrayBuffer());
        case "blob" /* Blob */:
            return result.blob();
        case "json" /* JSON */:
            return result.json();
        case "text" /* Text */:
            return result.text();
        default:
            throw new Error(`Unknown type "${type}"`);
    }
}

export { FetchMethods, FetchResultTypes, QueryError, fetch };
//# sourceMappingURL=index.mjs.map
