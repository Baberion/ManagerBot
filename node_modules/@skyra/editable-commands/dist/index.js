"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reply = exports.send = exports.get = exports.free = exports.track = void 0;
const discord_js_1 = require("discord.js");
const replies = new WeakMap();
/**
 * Tracks a response with a message, in a way that if {@link send} is called with `message`, `response` will be edited.
 * @param message The message to track when editing.
 * @param response The response to edit when using send with `message`.
 */
function track(message, response) {
    replies.set(message, response);
}
exports.track = track;
/**
 * Removes the tracked response for `message`.
 * @param message The message to free from tracking.
 * @returns Whether the message was tracked.
 */
function free(message) {
    return replies.delete(message);
}
exports.free = free;
/**
 * Gets the tracked response to `message`, if any was tracked and was not deleted.
 * @param message The message to get the reply from.
 * @returns The replied message, if any.
 */
function get(message) {
    const entry = replies.get(message);
    if (entry === undefined)
        return null;
    if (entry.deleted) {
        replies.delete(message);
        return null;
    }
    return entry;
}
exports.get = get;
/**
 * Sends a message as a response for `message`, and tracks it.
 * @param message The message to replies to.
 * @param options The options for the message sending, identical to `TextBasedChannel#send`'s options.
 * @returns The response message.
 */
async function send(message, options) {
    const payload = await resolvePayload(message.channel, options);
    return sendPayload(message, payload);
}
exports.send = send;
/**
 * Sends a reply message as a response for `message`, and tracks it.
 * @param message The message to replies to.
 * @param options The options for the message sending, identical to `TextBasedChannel#send`'s options.
 * @returns The response message.
 */
async function reply(message, options) {
    const payload = await resolvePayload(message.channel, options, { reply: resolveReplyOptions(message, options) });
    return sendPayload(message, payload);
}
exports.reply = reply;
function resolvePayload(target, options, extra) {
    options =
        typeof options === 'string' ? { content: options, embeds: [], attachments: [] } : { content: null, embeds: [], attachments: [], ...options };
    return discord_js_1.MessagePayload.create(target, options, extra).resolveData().resolveFiles();
}
function resolveReplyOptions(message, options) {
    if (typeof options === 'string')
        return { messageReference: message, failIfNotExists: message.client.options.failIfNotExists };
    return { messageReference: message, failIfNotExists: options.failIfNotExists ?? message.client.options.failIfNotExists };
}
async function sendPayload(message, payload) {
    const existing = get(message);
    const response = await (existing ? existing.edit(payload) : message.channel.send(payload));
    track(message, response);
    return response;
}
//# sourceMappingURL=index.js.map